#!/usr/bin/perl
#-*-perl-*-
#
# simple evaluation script to evaluate tree alignment output in
# Stockholm Tree Aligner format
#
# USAGE: eval_sta gold-file tree-alignments
#
# both files (gold-file & tree-alignments) 
# have to be in Stockholm Tree Aligner format!
#
#---------------------------------------------------------------------
#

use strict;
use FindBin;
use lib $FindBin::Bin.'/../lib';
use Lingua::Align::Corpus::Parallel::STA;

my $gold=shift(@ARGV);
my $sta1=new Lingua::Align::Corpus::Parallel::STA;
my $GoldLinks;
my $totalGold = $sta1->read_tree_alignments($gold,\$GoldLinks);

my $system=shift(@ARGV);
my $sta2=new Lingua::Align::Corpus::Parallel::STA;
my $SystemLinks;
my $totalSystem = $sta2->read_tree_alignments($system,\$SystemLinks);

my ($correct,$wrong,$correctGood,$totalGood)= (0,0,0,0);

# keep a hash of source sentence IDs which we actually have aligned
# this is a it tricky because we will not count sentences for which the
# aligner didn't find any alignments ... hmmm ...

my %srcIDs=();

foreach my $s (keys %{$SystemLinks}){
    if ($s=~/^(s[0-9]+)\_/){
	$srcIDs{$1}=1;
    }
    foreach my $t (keys %{$$SystemLinks{$s}}){
	if (exists $$GoldLinks{$s}){
	    if (exists $$GoldLinks{$s}{$t}){
		$correct++;
		if ($$GoldLinks{$s}{$t} eq 'good'){
		    $correctGood++;
		}
	    }
	    else{$wrong++;}
	}
	else{$wrong++;}
    }
}

# go through gold standard links
# - we have to count good alignments
# - we might want to skip some sentences 
#   (which we haven't aligned with the system to be evaluated)

my $total=0;
foreach my $s (keys %{$GoldLinks}){
    if ($s=~/^(s[0-9]+)\_/){
	next if (not exists $srcIDs{$1});
    }
    foreach my $t (keys %{$$GoldLinks{$s}}){
	$total++;
	next if ($$GoldLinks{$s}{$t} ne 'good');
	$totalGood++;
    }
}

if ($total != $totalGold){
    print "\nTotal links in gold standard = $totalGold\n";
    print "I will only use $total links from sentences";
    print " for which we actually have alignments!\n\n";
}




print "=======================================\n";
my $recallG;
if ($totalGood){
    my $precisionG = $correctGood/($correctGood+$wrong);
    $recallG = $correctGood/$totalGood;

    printf " precision (good) = %5.2f (%d/%d)\n",
    $precisionG*100,$correctGood,$correctGood+$wrong;
    printf "    recall (good) = %5.2f (%d/%d)\n",
    $recallG*100,$correctGood,$totalGood;
    printf "balanced F (good) = %5.2f\n",
    200*$precisionG*$recallG/($precisionG+$recallG);
    print "=======================================\n";
    
}

if ($total && $totalSystem){
    my $precision = $correct/$totalSystem;
    my $recall = $correct/$total;

    printf "        precision = %5.2f (%d/%d)\n",
    $precision*100,$correct,$totalSystem;
    printf "           recall = %5.2f (%d/%d)\n",
    $recall*100,$correct,$total;
    printf "       balanced F = %5.2f\n",
    200*$precision*$recall/($precision+$recall);
    print "=======================================\n";

    printf "F (P_all & R_good) = %5.2f\n",
    200*$precision*$recallG/($precision+$recallG);
    
}



