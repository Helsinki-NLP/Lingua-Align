#!/usr/bin/perl
#-*-perl-*-
#
# simple evaluation script to evaluate tree alignment output in
# Stockholm Tree Aligner format
#
# USAGE: eval_sta gold-file tree-alignments
#
# both files (gold-file & tree-alignments) 
# have to be in Stockholm Tree Aligner format!
#
#---------------------------------------------------------------------
#

use strict;
use FindBin;
use lib $FindBin::Bin.'/../lib';
use Lingua::Align::Corpus::Parallel::STA;

my $gold=shift(@ARGV);
my $sta1=new Lingua::Align::Corpus::Parallel::STA;
my $GoldLinks;
my $totalGold = $sta1->read_tree_alignments($gold,\$GoldLinks);

my $system=shift(@ARGV);
my $sta2=new Lingua::Align::Corpus::Parallel::STA;
my $SystemLinks;
my $totalSystem = $sta2->read_tree_alignments($system,\$SystemLinks);

my ($correct,$wrong,$correctGood,$totalGood)= (0,0,0,0);

# keep a hash of source sentence IDs which we actually have aligned
# this is a it tricky because we will not count sentences for which the
# aligner didn't find any alignments ... hmmm ...

my %srcIDs=();
my $s_is_term;
my $t_is_term;

my %CorrectTypes=();
my %WrongTypes=();


foreach my $s (keys %{$SystemLinks}){
    if ($s=~/^(s[0-9]+)\_/){
	$srcIDs{$1}=1;
    }

    if ($s=~/s?[0-9]+\_([0-9]+)$/){        # assume that node ID's < 500 
	if ($1 < 500){$s_is_term=1;}       # are terminal nodes
	else{$s_is_term=0;}
    }

    foreach my $t (keys %{$$SystemLinks{$s}}){

	if ($t=~/s?[0-9]+\_([0-9]+)$/){        # assume that node ID's < 500 
	    if ($1 < 500){$t_is_term=1;}       # are terminal nodes
	    else{$t_is_term=0;}
	}

	if (exists $$GoldLinks{$s}){
	    if (exists $$GoldLinks{$s}{$t}){

		$CorrectTypes{$$GoldLinks{$s}{$t}}{$s_is_term}{$t_is_term}++;
		$CorrectTypes{ALL}{$s_is_term}{$t_is_term}++;

		$correct++;
		if ($$GoldLinks{$s}{$t} eq 'good'){
		    $correctGood++;
		}
	    }
	    else{
		$WrongTypes{$s_is_term}{$t_is_term}++;
		$wrong++;
	    }
	}
	else{
	    $WrongTypes{$s_is_term}{$t_is_term}++;
	    $wrong++;
	}
    }
}

# go through gold standard links
# - we have to count good alignments
# - we might want to skip some sentences 
#   (which we haven't aligned with the system to be evaluated)

my $total=0;
my %TotalTypes=();

foreach my $s (keys %{$GoldLinks}){
    if ($s=~/^(s[0-9]+)\_/){
	next if (not exists $srcIDs{$1});
    }

    if ($s=~/s?[0-9]+\_([0-9]+)$/){        # assume that node ID's < 500 
	if ($1 < 500){$s_is_term=1;}       # are terminal nodes
	else{$s_is_term=0;}
    }

    foreach my $t (keys %{$$GoldLinks{$s}}){

	if ($t=~/s?[0-9]+\_([0-9]+)$/){        # assume that node ID's < 500 
	    if ($1 < 500){$t_is_term=1;}       # are terminal nodes
	    else{$t_is_term=0;}
	}

	$TotalTypes{$$GoldLinks{$s}{$t}}{$s_is_term}{$t_is_term}++;
	$TotalTypes{ALL}{$s_is_term}{$t_is_term}++;

	$total++;
	next if ($$GoldLinks{$s}{$t} ne 'good');
	$totalGood++;
    }
}

if ($total != $totalGold){
    print "\nTotal links in gold standard = $totalGold\n";
    print "I will only use $total links from sentences";
    print " for which we actually have alignments!\n\n";
}

#----------------------------------------------------------------
# print scores per type (T:T, NT:NT, all, good, fuzzy)

foreach my $type (sort keys %TotalTypes){
    next if ($type eq 'comment');
    foreach my $s (sort keys %{$TotalTypes{$type}}){
	foreach my $t (sort keys %{$TotalTypes{$type}}){

	    ## only if there is anything to say ....
	    next if ((not $CorrectTypes{$type}{$s}{$t}) &&
		     (not $WrongTypes{$s}{$t}));

	    print "--------------------------------------------------------\n";

	    my $precision=0;
	    if ($CorrectTypes{$type}{$s}{$t} || $WrongTypes{$s}{$t}){
		$precision = $CorrectTypes{$type}{$s}{$t}/
		    ($CorrectTypes{$type}{$s}{$t}+$WrongTypes{$s}{$t});
	    }
	    my $recall=0;
	    if ($TotalTypes{$type}{$s}{$t}){
		$recall=$CorrectTypes{$type}{$s}{$t}/
		    $TotalTypes{$type}{$s}{$t};
	    }

	    my $st = 'NT';
	    if ($s){$st = 'T';}
	    my $tt = 'NT';
	    if ($t){$tt = 'T';}

	    printf "%30s = %5.2f (%d/%d)\n",
	    "precision ($type/$st:$tt)",
	    $precision*100,
	    $CorrectTypes{$type}{$s}{$t},
	    $CorrectTypes{$type}{$s}{$t}+$WrongTypes{$s}{$t};

	    printf "%30s = %5.2f (%d/%d)\n",
	    "recall ($type/$st:$tt)",
	    $recall*100,
	    $CorrectTypes{$type}{$s}{$t},
	    $TotalTypes{$type}{$s}{$t};

	    my $F=0;
	    if ($recall || $precision){
		$F=2*$precision*$recall/($precision+$recall);
	    }
	    printf "%30s = %5.2f\n","balanced F ($type/$st:$tt)",100*$F;
	}
    }
}

print "\n\n";


#----------------------------------------------------------------
# print total numbers


print "=======================================\n";
my $recallG;
if ($totalGood){
    my $precisionG = $correctGood/($correctGood+$wrong);
    $recallG = $correctGood/$totalGood;

    printf " precision (good) = %5.2f (%d/%d)\n",
    $precisionG*100,$correctGood,$correctGood+$wrong;
    printf "    recall (good) = %5.2f (%d/%d)\n",
    $recallG*100,$correctGood,$totalGood;
    my $F = 0;
    if ($precisionG || $recallG){
	$F = 2*$precisionG*$recallG/($precisionG+$recallG);
    }
    printf "balanced F (good) = %5.2f\n",100*$F;
    print "=======================================\n";
    
}

if ($total && $totalSystem){
    my $precision = $correct/$totalSystem;
    my $recall = $correct/$total;

    printf "        precision = %5.2f (%d/%d)\n",
    $precision*100,$correct,$totalSystem;
    printf "           recall = %5.2f (%d/%d)\n",
    $recall*100,$correct,$total;
    my $F = 0;
    if ($precision || $recall){
	$F = 2*$precision*$recall/($precision+$recall);
    }
    printf "       balanced F = %5.2f\n",100*$F;
    print "=======================================\n";

    if ($precision || $recallG){
	$F = 2*$precision*$recallG/($precision+$recallG);
    }
    printf "F (P_all & R_good) = %5.2f\n",100*$F;
    print "=======================================\n";
    
}



