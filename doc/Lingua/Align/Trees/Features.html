<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lingua::Align::Trees::Features - Perl modules for feature extraction for the Lingua::Align::Trees tree aligner</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#features">FEATURES</a></li>
		<ul>

			<li><a href="#lexical_equivalence_features">lexical equivalence features</a></li>
			<li><a href="#word_alignment_features">word alignment features</a></li>
			<li><a href="#sub_tree_features">sub-tree features</a></li>
			<li><a href="#annotation_label_features">annotation/label features</a></li>
		</ul>

	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Lingua::Align::Trees::Features - Perl modules for feature extraction for the Lingua::Align::Trees tree aligner</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use Lingua::Align::Trees::Features;</pre>
<pre>
  my $FeatString = 'catpos:treespansim:parent_catpos';
  my $extractor = new Lingua::Align::Trees::Features(
                          -features =&gt; $FeatString);</pre>
<pre>
  my %features = $extractor-&gt;features(\%srctree,\%trgtree,
                                      $srcnode,$trgnode);</pre>
<pre>
  my $FeatString2 = 'giza:gizae2f:gizaf2e:moses';
  my $extractor2 = new Lingua::Align::Trees::Features(
                      -features =&gt; $FeatString2,
                      -lexe2f =&gt; 'moses/model/lex.0-0.e2f',
                      -lexf2e =&gt; 'moses/model/lex.0-0.f2e',
                      -moses_align =&gt; 'moses/model/aligned.intersect');</pre>
<pre>
  my %features = $extractor2-&gt;features(\%srctree,\%trgtree,
                                       $srcnode,$trgnode);</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Extract features from a pair of nodes from two given syntactic trees (source and target language). The trees should be complex hash structures as produced by Lingua::Align::Corpus::Treebank::TigerXML. The returned features are given as simple key-value pairs (%features)</p>
<p>Features to be used are specified in the feature string given to the constructor ($FeatString). Default is 'inside2:outside2' which refers to 2 features, the inside score and the outside score as defined by the Dublin Sub-Tree Aligner (see <a href="http://www2.sfs.uni-tuebingen.de/ventzi/Home/Software/Software.html,">http://www2.sfs.uni-tuebingen.de/ventzi/Home/Software/Software.html,</a> <a href="http://ventsislavzhechev.eu/Downloads/Zhechev%20MT%20Marathon%202009.pdf).">http://ventsislavzhechev.eu/Downloads/Zhechev%20MT%20Marathon%202009.pdf).</a> For this you will need the probabilistic lexicons as created by Moses (http://statmt.org/moses/); see the -lexe2f and -lexf2e parameters in the constructor of the second example.</p>
<p>Features in the feature string are separated by ':'. Feature types can be combined. Possible combinations are:</p>
<dl>
<dt><strong><a name="product" class="item">product (*)</a></strong></dt>

<dd>
<p>multiply the value of 2 or more feature types, e.g. 'inside2*outside2' would refer to the product of inside2 and outside2 scores</p>
</dd>
<dt><strong><a name="average" class="item">average (+)</a></strong></dt>

<dd>
<p>compute the average (arithmetic mean) of 2 or more features,  e.g. 'inside2+outside2' would refer to the mean of inside2 and outside2 scores</p>
</dd>
<dt><strong><a name="concatenation" class="item">concatenation (.)</a></strong></dt>

<dd>
<p>merge 2 or more feature keys and compute the average of their scores. This can especially be useful for &quot;nominal&quot; feature types that have several instantiations. For example, 'catpos' refers to the labels of the nodes (category or POS label) and the value of this feature is either 1 (present). This means that for 2 given nodes the feature might be 'catpos_NN_NP =&gt; 1' if the label of the source tree node is 'NN' and the label of the target tree node is 'NP'. Such nominal features can be combined with real valued features such as inside2 scores, e.g. 'catpos.inside2' means to concatenate the keys of both feature types and to compute the arithmetic mean of both scores.</p>
</dd>
</dl>
<p>We can also refer to parent nodes on source and/or target language side. A feature with the prefix 'parent_' makes the feature extractor to take the corresponding values from the first parent nodes in source and target language trees. The prefix 'srcparent_' takes the values from the source language parent (but the current target language node) and 'trgparent_' takes the target language parent but not the source language parent. For example 'parent_catpos' gets the labels of the parent nodes. These feature types can again be combined with others as described above (product, mean, concatenation). We can also use 'sister_' features 'children_' features which will refer to the feature with the maximum value among all sister/children nodes, respectively.</p>
<p>
</p>
<h2><a name="features">FEATURES</a></h2>
<p>The following feature types are implemented in the Tree Aligner:</p>
<p>
</p>
<h3><a name="lexical_equivalence_features">lexical equivalence features</a></h3>
<p>Lexical equivalence features evaluate the relations between words dominated by the current subtree root nodes (alignment candidates). They all use lexical probabilities usually derived from automatic word alignment (other types of probabilistic lexica could be used as well). The notion of inside words refers to terminal nodes that are dominated by the current subtree root nodes and outside words refer to terminal nodes that are not dominated by the current subtree root nodes. Various variants of scores are possible:</p>
<dl>
<dt><strong><a name="inside1" class="item">inside1 (insideST1*insideTS1)</a></strong></dt>

<dd>
<p>This is the unnormalized score of words inside of the current subtrees (see <a href="http://ventsislavzhechev.eu/Downloads/Zhechev%20MT%20Marathon%202009.pdf).">http://ventsislavzhechev.eu/Downloads/Zhechev%20MT%20Marathon%202009.pdf).</a> Lexical probabilities are taken from automatic word alignment (lex-files). NULL links  are also taken into account. It is actually the product of insideST1 (probabilities from source-to-target lexicon) and insideTS1 (probabilities from target-to-source lexicon) which also can be used separately (as individual features).</p>
</dd>
<dt><strong><a name="outside1" class="item">outside1 (outsideST1*outsideTS1)</a></strong></dt>

<dd>
<p>The same as inside1 but for word pairs outside of the current subtrees. NULL links are counted and scores are not normalized.</p>
</dd>
<dt><strong><a name="inside2" class="item">inside2 (insideST2*insideTS2)</a></strong></dt>

<dd>
<p>This refers to the normalized inside scores as defined in the Dublin Subtree Aligner.</p>
</dd>
<dt><strong><a name="outside2" class="item">outside2 (outsideST1*outsideTS1)</a></strong></dt>

<dd>
<p>The normalized scores of word pairs outside of the subtrees.</p>
</dd>
<dt><strong><a name="inside3" class="item">inside3 (insideST3*insideTS3)</a></strong></dt>

<dd>
<p>The same as inside1 (unnormalized) but without considering NULL links (which makes feature extraction much faster)</p>
</dd>
<dt><strong><a name="outside3" class="item">outside3 (outsideST1*outsideTS1)</a></strong></dt>

<dd>
<p>The same as outside1 but without NULL links.</p>
</dd>
<dt><strong><a name="inside4" class="item">inside4 (insideST4*insideTS4)</a></strong></dt>

<dd>
<p>The same as inside2 but without NULL links.</p>
</dd>
<dt><strong><a name="outside4" class="item">outside4 (insideST4*insideTS4)</a></strong></dt>

<dd>
<p>The same as outside2 but without NULL links.</p>
</dd>
<dt><strong><a name="maxinside" class="item">maxinside (maxinsideST*maxinsideTS)</a></strong></dt>

<dd>
<p>This is basically the same as inside4 but using &quot;max P(x|y)&quot; instead of &quot;1/|y \SUM P(x|y)&quot; as in the original definition. maxinsideST is using the source-to-target scores and maxinsideTS is using the target-to-source scores.</p>
</dd>
<dt><strong><a name="maxoutside" class="item">maxoutside (maxoutsideST*maxoutsideTS)</a></strong></dt>

<dd>
<p>The same as maxinside but for outside word pairs</p>
</dd>
<dt><strong><a name="avgmaxinside" class="item">avgmaxinside (avgmaxinsideST*avgmaxinsideTS)</a></strong></dt>

<dd>
<p>This is the same as maxinside but computing the average (1/|x|\SUM_x max P(x|y)) instead of the product (\PROD_x max P(x|y))</p>
</dd>
<dt><strong><a name="avgmaxoutside" class="item">avgmaxoutside (avgmaxoutsideST*avgmaxoutsideTS)</a></strong></dt>

<dd>
<p>The same as avgmaxinside but for outside word pairs</p>
</dd>
<dt><strong><a name="unioninside" class="item">unioninside (unioninsideST*unioninsideTS)</a></strong></dt>

<dd>
<p>Add all lexical probabilities using the addition rule of independent but not mutually exclusive probabilities (P(x1|y1)+P(x2|y2)-P(x1|y1)*P(x2|y2))</p>
</dd>
<dt><strong><a name="unionoutside" class="item">unionoutside (unionoutsideST*unionoutsideTS)</a></strong></dt>

<dd>
<p>The same as unioninside but for outside word pairs.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="word_alignment_features">word alignment features</a></h3>
<p>Word alignment features use the automatic word alignment directly. Again we distinguish between words that are dominated by the current subtree root nodes (inside) and the ones that are outside. Alignment is binary (1 if two words are aligned and 0 if not) and as a score we usuallty compute the proportion of interlinked inside word pairs among all links involving either source or target inside words. One exception is the moselink feature which is only defined for terminal nodes.</p>
<dl>
<dt><strong><a name="moses" class="item">moses</a></strong></dt>

<dd>
<p>The proportion of interlinked words (from automatic word alignment) inside of the current subtree among all links involving either source or target words inside of the subtrees.</p>
</dd>
<dt><strong><a name="moseslink" class="item">moseslink</a></strong></dt>

<dd>
<p>Only for terminal nodes: is set to 1 if the twwo words are linked in the automatic word alignment derived from GIZA++/Moses.</p>
</dd>
<dt><strong><a name="gizae2f" class="item">gizae2f</a></strong></dt>

<dd>
<p>Link proportion as for moses but now using the assymmetric GIZA++ alignments only (source-to-target).</p>
</dd>
<dt><strong><a name="gizaf2e" class="item">gizaf2e</a></strong></dt>

<dd>
<p>Link proportion as for moses but now using the assymmetric GIZA++ alignments only (target-to-source).</p>
</dd>
<dt><strong><a name="giza" class="item">giza</a></strong></dt>

<dd>
<p>Links from gizae2f and gizaf2e combined.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="sub_tree_features">sub-tree features</a></h3>
<p>Sub-tree features refer to features that are related to the structure and position of the current subtrees.</p>
<dl>
<dt><strong><a name="treespansim" class="item">treespansim</a></strong></dt>

<dd>
<p>This is a feature for measuring the &quot;horizontal&quot; similarity of the subtrees under consideration. It is defined as the 1 - the relative position difference of the subtree spans. The relative position of a subtree is defined as the middle of the span of a subtree (begin+end/2) divided by the length of the sentence.</p>
</dd>
<dt><strong><a name="treelevelsim" class="item">treelevelsim</a></strong></dt>

<dd>
<p>This is a feature measuring the &quot;vertical&quot; similarity of two nodes. It is defined as 1 - the relative tree level difference. The relative tree level is defined as the distance to the sentence root node divided by the size of the tree (which is the maximum distance of any node in the tree to the sentence root).</p>
</dd>
<dt><strong><a name="nrleafsratio" class="item">nrleafsratio</a></strong></dt>

<dd>
<p>This is the ratio of the number of leaf nodes dominated by the two candidate nodes. The ratio is defined as the minimum(nr_src_leafs/nr_trg_leafs,nr_trg_leafs/nr_src_leafs).</p>
</dd>
</dl>
<p>
</p>
<h3><a name="annotation_label_features">annotation/label features</a></h3>
<dl>
<dt><strong><a name="catpos" class="item"><code>catpos</code></a></strong></dt>

<dd>
<p>This feature type extracts node label pairs and gives them the value 1. It uses the &quot;cat&quot; attribute if it exists, otherwise it uses the &quot;pos&quot; attribute if that one exists.</p>
</dd>
<dt><strong><a name="edge" class="item"><code>edge</code></a></strong></dt>

<dd>
<p>This feature refers to the pairs of edge labels (relations) of the current nodes to their immediate parent (only the first parent is considered if multiple exist). This is a binary feature and is set to 1 for each observed label pair.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>For the tree structure see <a href="/~tiedeman/Lingua/Align/Corpus/Treebank.html">the Lingua::Align::Corpus::Treebank manpage</a>.
For the tree aligner look at <a href="/~tiedeman/Lingua/Align/Trees.html">the Lingua::Align::Trees manpage</a></p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Joerg Tiedemann, &lt;<a href="mailto:j.tiedemann@rug.nl">j.tiedemann@rug.nl</a>&gt;</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<p>Copyright (C) 2009 by Joerg Tiedemann</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.</p>

</body>

</html>
